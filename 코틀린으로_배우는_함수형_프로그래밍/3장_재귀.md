# 3장. 재귀

함수형 프로그래밍에서는 명령문을 반복할 때 루프 대신에 재귀를 사용한다.

함수형 프로그래밍에서 재귀가 가지는 의미를 알아보고, 재귀적으로 생각하고 설계하는 방법을 알아보자.

## 3.1 함수형 프로그래밍에서 재귀가 가지는 의미

재귀는 어떤 함수의 구현 내부에서 자기 자신을 호출하는 함수를 정의하는 방법을 말한다.

### 피보나치 수열을 명령형 프로그래밍으로 구현한 예제

```kotlin
fun main() {
    println(fiboDinamic(10, IntArray(100)))
}

private fun fiboDinamic(n: Int, fibo: IntArray): Int {
    fibo[0] = 0
    fibo[1] = 1

    for (i in 2..n) {
        fibo[i] = fibo[i - 1] + fibo[i - 2]
    }

    return fibo[n]
}
```

`IntArray(100)` 을 사용하여 피보나치 수열의 이전 값들을 기억한다. 따라서 이 예제에서는 피보나치 수열을 100개 까지만 계산할 수 있다.

### 피보나치 수열을 재귀로 구현한 예제

```kotlin
fun main() {
    println(fiboRecursion(10))
}

private fun fiboRecursion(n: Int): Int = when (n) {
    0 -> 0
    1 -> 1
    else -> fiboRecursion(n - 1) + fiboRecursion((n - 2))
}
```

메모리를 직접 할당해서 사용하지 않고, 스택을 활용한다.

재귀 호출을 사용하면 컴파일러는 내부적으로 현재 호출하는 함수에 대한 모든 정보를 스택에 기록해두고 다음 함수를 호출한다.

`fiboRecursion(150)` 의 경우 출력이 안된다...?!

### 함수형 프로그래밍에서 재귀

함수형 프로그래밍에서는 어떻게(how) 값을 계산할 수 있을지 선언하는 대신 무엇을(what) 선언할지를 고민해야한다.

재귀는 반복문에 비하여 복잡한 알고리즘을 간결하게 표현할 수 있지만, 다음과 같은 문제점을 가진다.

- 동적 계획법 방식에 비해서 성능이 느리다.
- 스택 오버플로 오류(stack overflow error)가 발생할 수 있다.

## 3.2 재귀를 설계하는 방법

재귀가 무한루프에 빠지지 않으려면 재귀에서 빠져 나오는 종료조건(edge condition)이 적어도 한 개 이상 존재해야 하고 재귀를 반복할수록 종료조건으로 수렴해야 한다.

- 종료조건(edge condition)정의
- 함수의 입력을 분할하여 어떤 부분에서 재귀 호출을 할지 결정
- 함수의 입력값이 종료조건으로 수렴하도록 재귀 호출의 입력값을 결정

종료조건을 정의할 때는 자료구조가 더는 쪼개지지 않아 재귀의 과정이 더 이상 의미 없는 값을 사용한다. 일반적으로 이런 값은 항등값이다.

함수의 입력을 분할할 때는 수학적 귀납법과 동일한 패턴을 적용한다. 어떤 구성요소(예를 들면 리스트의 첫 번째 값)와 나머지 구성요소로 최종 결과값을 만들기 위한 함수의 동작을 구현한다.

### 연습문제 3-2

```kotlin
fun power(x: Double, n: Int): Double = when (n) {
    0 -> 1.0
    1 -> x
    else -> x * power(x, n - 1)
}
```

### 연습문제 3-3

```kotlin
fun factorial(n: Int): Int = when (n) {
    0 -> 1
    else -> n * factorial(n - 1)
}
```