# 2장. 코틀린으로 함수형 프로그래밍 시작하기

앞으로의 예제를 이해햐기 위해 코틀린 문법 간단히 알아보기

## 2.1 프로퍼티 선언과 안전한 널 처리

### 프로퍼티 선언

- 읽기 전용 프로퍼티

```kotlin
val value: Int = 10
```

`val` 은 읽기 전용 프로퍼티를 선언하는 예약어로 자바에서 `final` 로 선언한 변수와 기능이 유사하다.

- 가변 프로퍼티

```kotlin
var variable: Int = 10
```

`var` 은 선언 이후에 수정 가능한 가변(mutable) 프로퍼티를 나타내는 것으로 자바에서 일반 변수로 선언한 것과 기능이 같다.

- 타입 추론을 사용한 선언

```kotlin
val value = 10
var variable = 10
```

### 안전한 널 처리

코틀린 언어에서 안전한 널처리(null safety) 기능을 제공함

```kotlin
val nonNull: Int = null // 컴파일 오류 발생
val nullable: Int? = null
```

## 2.2 함수와 람다

### 함수를 선언하는 다양한 방법

```kotlin
fun twice1(value: Int): Int {
    return value * 2
}

fun twice2(value: Int): Int = value * 2

fun twice3(value: Int) = value * 2
```

함수 코드 블록(`{}`)에서 `return` 을 사용하는 경우 타입 추론을 하지 않기 때문에 함수의 반환 타입을 항상 명시해야 한다.

함수에서 `Unit` 타입은 자바의 `void` 와 유사하게 아무것도 반환하지 않는 것을 뜻한다.

### 매개변수에 기본값 설정하기

```kotlin
fun add(x: Int = 10, y: Int = 3): Int = x + y

println(add()) // 13
println(add(7)) // 19
// y에만 값을 주기
println(add(y=10)) // 20
```

### 익명 함수와 람다 표현식

익명 함수는 함수 이름을 선언하지 않고, 구현부만 작성하는 함수를 표현하는 방식의 일종이다.

```kotlin
fun sum(x: Int, y: Int, calculate: (Int, Int) -> Int): Int {
    return calculate(x, y)
}

val value = sum(5, 10) { x, y -> x + y }
println(value)
```

`{ x, y -> x + y }` 은 람다식으로 `calculate` 에 바인딩된다.

람다식은 `return` 을 사용하지 않으면 마지막 라인의 결과가 반환된다.

### 확장 함수

코틀린에서는 상속을 하거나 내부를 수정하지 않고도 이미 작성된 클래스에 함수나 프로퍼티를 추가할 수 있다.

이렇게 새롭게 추가한 함수를 확장 함수(extension function)라 한다.

```kotlin
fun Int.product(value: Int): Int {
    return this * value
}

println(10.product(2))
```

### 연습문제 2-1

```kotlin
// 연습문제 2-1
fun String.sayHello(): String {
    return "Hello, $this"
}

println("World".sayHello())
println("Kotlin".sayHello())
```

## 2.3 제어 구문

### if문

코틀린에서 `if` 문은 기본적으로 표현식이라 결과로서 어떤 값을 반환해야한다.

```kotlin
val x = 3
val y = 7
val max: Int = if (x > y) x else y

println(max)
```

`else` 를 작성하지 않으면 컴파일 오류가 발생한다.

### when문

자바의 `switch` 문이나 스칼리의 패턴 매칭과 유사한 기능을 한다.

```kotlin
val x: Int = 1
when (x) {
    1 -> print("x == 1")
    2, 3 -> print("x == 2 or 3")
    parseInt("4") -> print("x == 4")
    else -> print("else number")
}
```

`x` 가 어떤 조건과 매칭되었을 때 동작을 다음과 같이 정의할 수 있다.

```kotlin
val x: Int = 1
val numType = when {
    x == 0 -> "zero"
    x > 0 -> "positive"
    else -> "negative"
}
```

`if` 문과 마찬가지로 표현식이므로 결과값을 프로퍼티에 할당하기 위해서는 반드시 `else` 를 작성해야 한다.

### for문

```kotlin
val collection = listOf(1, 2, 3)

for (item in collection) {
    print(item) // 123
}

for ((index, item) in collection.withIndex()) {
    println("the element at $index is $item")
}
// the element at 0 is 1
// the element at 1 is 2
// the element at 2 is 3
```

코틀린에서는 루프를 작성할 때 값의 범위 및 증감 규칙을 설정할 수 있다.

```kotlin
for (i in 1..3) {
    print(i) // 123
}

// until은 Expecting 'in' 에러가 발생

for (i in 6 downTo 0 step 2) {
    print(i) // 6420
}
```

## 2.4 인터페이스

### 인터페이스의 특징

코틀린 인터페이스의 특징

- 다중 상속이 가능하다.
- 추상(abstract) 함수를 가질 수 있다.
- 함수의 본문을 구현할 수 있다.
- 여러 인터페이스에서 같은 이름의 함수를 가질 수 있다.
- 추상 프로퍼티를 가질 수 있다.

### 인터페이스 선언하고 상속하기

```kotlin
interface Foo {

}

interface Bar {
    
}

class Kotlin: Foo, Bar {
    
}
```

코틀린에서는 `:` 로 상속을 표현한다. 그리고 여러 개의 인터페이스를 상속하기 위해서 `,` 를 구분자로 사용한다.

### 인터페이스에 추상 함수 선언하기

```kotlin
interface Foo {
    fun printFoo()
}

interface Bar {
    fun printBar()
}

class Kotlin: Foo, Bar {
    override fun printFoo() {
        println("Foo")
    }

    override fun printBar() {
        println("Bar")
    }
}
```

상속한 클래스에서 인터페이스의 추상 함수를 재정의할 때는 `override` 키워드를 사용한다.

### 추상 함수 구현하기

두 인터페이스에서 동일한 이름의 추상 함수가 선언되어있다면, 다중 상속한 클래스에서 어떻게 구분해서 호출하는지 확인해보자.

```kotlin
interface Foo {
    fun printFoo()
    fun printKotlin() {
        println("Foo Kotlin")
    }
}

interface Bar {
    fun printBar()
    fun printKotlin() {
        println("Bar Kotlin")
    }
}

class Kotlin: Foo, Bar {
    override fun printFoo() {
        println("Foo")
    }

    override fun printBar() {
        println("Bar")
    }

    override fun printKotlin() {
        super<Foo>.printKotlin()
        super<Bar>.printKotlin()
    }
}
```

`super<Foo>.printKotlin()` 과 같은 방식으로 상속받은 인터페이스의 함수를 선택해서 사용하면 된다.

### 추상 프로퍼티의 선언과 사용

```kotlin
interface Foo {
    val bar: Int
    fun printFoo()
    fun printKotlin() {
        println("Foo Kotlin")
    }
}

interface Bar {
    fun printBar()
    fun printKotlin() {
        println("Bar Kotlin")
    }
}

class Kotlin: Foo, Bar {
    override val bar: Int = 3

    override fun printFoo() {
        println("Foo")
    }

    override fun printBar() {
        println("Bar")
    }

    override fun printKotlin() {
        super<Foo>.printKotlin()
        super<Bar>.printKotlin()
    }
}

fun main() {
    val kotlin = Kotlin()
    println(kotlin.bar) // 3
}
```