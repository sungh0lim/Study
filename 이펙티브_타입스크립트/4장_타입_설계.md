# 타입 설계

코드의 타입을 제대로 작성한다면 코드의 로직 역시 명백할 것이다.

## 아이템 28. 유효한 상태만 표현하는 타입을 지향하기

타입을 잘 설계하면 코드는 직관적으로 작성할 수 있습니다.

```tsx
interface RequestPending {
  state: "pending";
}
interface RequestError {
  state: "error";
  error: string;
}
interface RequestSuccess {
  state: "ok";
  pageText: string;
}
type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  currentPage: string;
  requests: { [page: string]: RequestState };
}
```

타입을 설계할 때는 어떤 값들을 포함하고 어떤 값들을 제외할지 신중하게 생각해야 합니다.

유효한 상태만 표현하는 타입을 지향해야 합니다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있습니다.

## 아이템29. 사용할 때는 너그럽게, 생성할 때는 엄격하게

함수의 매개변수는 타입의 범위가 넓어도 되지만, 결과를 반환할 때는 일반적으로 타입의 범위가 더 구체적이여야 합니다.

```tsx
type LngLat =
  | { lng: number; lat: number }
  | { lon: number; lat: number }
  | [number, number];
type LngLatBounds =
  | { northeast: LngLat; southwest: LngLat }
  | [LngLat, LngLat]
  | [number, number, number, number];
```

`LngLatBounds` 의 가능한 형태는 19가지 이상으로 매우 자유로운 타입입니다.

따라서 반환 타입이 `LngLatBounds` 인 경우 아래의 예제와 같이 다루기 어려울 수 있습니다.

```tsx
type LngLat = { lng: number; lat: number } | { lon: number; lat: number } | [number, number]
type LngLatBounds = { northeast: LngLat; southwest: LngLat } | [LngLat, LngLat] | [number, number, number, number]
declare function setCamera(camera: CameraOptions): void
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions
type Feature = any
declare function calculateBoundingBox(f: Feature): [number, number, number, number]
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f)
  const camera = viewportForBounds(bounds)
  setCamera(camera)
  const {
    center: { lat, lng },
    zoom,
  } = camera
  // ~~~      Property 'lat' does not exist on type ...
  //      ~~~ Property 'lng' does not exist on type ...
  zoom // Type is number | undefined
```

수많은 선택적 속성을 가지는 반환 타입과 유니온 타입은 `calculateBoundingBox` 를 사용하기 어렵게 만듭니다. 매개변수 타입의 범위가 넓으면 사용하기 편리하지만, 반환 타입의 범위가 넓으면 불편합니다. 즉, 사용하기 편리한 API 일수록 반환 타입이 엄격합니다.

```tsx
interface LngLat {
  lng: number;
  lat: number;
}
type LngLatLike = LngLat | { lon: number; lat: number } | [number, number];

interface Camera {
  center: LngLat;
  zoom: number;
  bearing: number;
  pitch: number;
}
interface CameraOptions extends Omit<Partial<Camera>, "center"> {
  center?: LngLatLike;
}
type LngLatBounds =
  | { northeast: LngLatLike; southwest: LngLatLike }
  | [LngLatLike, LngLatLike]
  | [number, number, number, number];

declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): Camera;
```

### Partial<Type>

Constructs a type with all properties of `Type`
 set to optional. This utility will return a type that represents all subsets of a given type.

```tsx
interface Todo {
  title: string;
  description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {
  return { ...todo, ...fieldsToUpdate };
}

const todo1 = {
  title: "organize desk",
  description: "clear clutter",
};

const todo2 = updateTodo(todo1, {
  description: "throw out trash",
});
```

Post 하는 경우에 일부 Optional로 바꾸어야하는 경우가 있는데 적용하면 좋겠다.

## 아이템30. 문서에 타입 정보를 쓰지 않기

“코드와 주석이 맞지 않는다면, 둘 다 잘못된 것이다!”

단위가 있는 숫자들은 변수명 또는 속성 이름에 단위를 포함하는 것이 좋다.

ex. `timeMs` , `temperatureC`

## 아이템31. 타입 주변에 null값 배치하기

### null이 아님 단언

```tsx
const [min, max] = extent([0, 1, 2])!;
const span = max - min; // OK
```

### if 구문으로 체크

```tsx
const range = extent([0, 1, 2]);
if (range) {
  const [min, max] = range;
  const span = max - min; // OK
}
```

## 아이템32. 유니온의 인터페이스보다는 인터페이스의 유니온을 사용하기

```tsx
interface FillLayer {
  type: "fill";
  layout: FillLayout;
  paint: FillPaint;
}
interface LineLayer {
  type: "line";
  layout: LineLayout;
  paint: LinePaint;
}
interface PointLayer {
  type: "paint";
  layout: PointLayout;
  paint: PointPaint;
}
type Layer = FillLayer | LineLayer | PointLayer;
function drawLayer(layer: Layer) {
  if (layer.type === "fill") {
    const { paint } = layer; // Type is FillPaint
    const { layout } = layer; // Type is FillLayout
  } else if (layer.type === "line") {
    const { paint } = layer; // Type is LinePaint
    const { layout } = layer; // Type is LineLayout
  } else {
    const { paint } = layer; // Type is PointPaint
    const { layout } = layer; // Type is PointLayout
  }
}
```

유니온 타입의 속성을 가지는 인터페이스를 작성하기보다는 인터페이스의 유니온 타입을 사용하는게 더 알맞지 않을지 검토가 필요하다.

## 아이템33. string 타입보다 더 구체적인 타입 사용하기

`string` 타입의 범위는 매우 넓습니다. `string` 타입으로 변수를 선언하려 한다면, 혹시 그보다 더 좁은 타입이 적절하지는 않을지 검토해 보아야 합니다.

### keyof 사용

```tsx
function pluck<T>(record: T[], key: string): any[] {
  return record.map((r) => r[key]);
  // ~~~~~~ Element implicitly has an 'any' type
  //        because type '{}' has no index signature
}

function pluck<T>(record: T[], key: keyof T) {
  return record.map((r) => r[key]);
}

function pluck<T, K extends keyof T>(record: T[], key: K): T[K][] {
  return record.map((r) => r[key]);
}
```
