# 5장. 큰 유리수

유리수 시스템은 두 개의 숫자, 즉 분자(numerator)와 분모(denominator)로 구성됩니다.

```
값 = 분자 / 분모

1.5 = 3 / 2
```

분모는 항상 양수인 상태로 유지함.

큰 유리수 계산하는 라이브러리도 열심히 만듬.

# 6장. 불(boolean) 타입

- 불 타입은 두 개의 값, 즉 `true` 와 `false` 만 가질 수 있다.
- `typeof` 연산자는 `true` 나 `false` 값에 대해서 `"boolean"` 을 반환한다.

## 관계 연산자

```jsx
undefined < null; // false
undefined > null; // false
undefined === null; // false

NaN === NaN; // false
NaN !== NaN; // true

"11" < "2"; // true
"2" < 5; // true
5 < "11"; // true
```

- `===` 와 `!==` 은 양쪽 피연산자가 `NaN` 인 경우를 제외하면 기대한 대로 동작함.
  - `x` 가 `NaN` 인지 확인하려면 반드시 `Number.isNaN(x)` 를 써야함.
- 반복문의 종료 조건을 검사하기 위해 연산자를 사용하고 싶다면, 종료 조건을 나타내는 변수 값이 안전한 정수 범위 안에 있을 경우만 사용하세요. (TS 를 써야지…)
  - 안전한 범위 안이라고 해도, `===` 보다는 `>=` 연산자가 더 안전합니다.
    - …?! `true >= 1` 이런 경우가 있는데…?
    - 예측 범위 밖을 벗어나도 동작한다는 의미인가…?
  - 자료형을 섞어서 사용하는 것을 막지 않기 때문에(연산자 오버로딩…?) 여러분 나름의 규칙을 가져야 합니다.
- `==` 와 `!=` 은 사용하지 않기를 권장
  - 비교 연산을 하기 전에 강제로 형변환을 함.

## 불인 척하기

불이 제대로 쓰이는 위치는 다음과 같습니다.

- `if` 문의 조건문 위치
- `while` 문의 조건문 위치
- `for` 문의 조건문 위치
- `do` 문의 조건문 위치
- `!` 연산자의 피연산자 위치
- `&&` 연산자의 양쪽 피연산자
- `||` 연산자의 양쪽 피연산자
- `?` 와 `:` 로 구성된 삼항 연산자의 첫 번째 피연산자 위치
- `Array` 의 `filter` , `find` , `findIndex` , `indexOf` 메서드의 첫 번째 인자로 전달되는 함수의 반환 값

잘 설계된 언어라면, 이런 위치에서는 오직 불 값만 사용하도록 할 것입니다. 하지만 JS는 여기에 아무 값이나 사용해도 된다.

이러한 아무 값은 ‘불인 척하는' 자료형에 포함된다.

- `false`
- `null`
- `undefined`
- `""` (빈문자열)
- `0`
- `NaN`

다른 모든 값은 ‘참이라고 볼 수 있는 값'에 해당합니다.

‘거짓이라고 볼 수 있는 값’들은 일반적으로 `false` 처럼 동작하지만, 엄밀히 말하면 이런 값들 대부분은 `false` 가 아닙니다.

저자는 자바와 같이 조건문이 반드시 불 값이 되도록 강제해서 이러한 에러를 제거함.

JS 에서도 조건문이 반드시 불 값을 쓰기를 권장함.

## 논리 연산자

논리 연산자 역시 ‘불인 척하기'의 피해자…

## 하지 마세요!

‘불인 척하는 값'을 사용하면 수학에서 비교연산자를 간소화 하는 것이 실패할 수 있음.

드모르간 법칙 또한 마찬가지.

# 7장. 배열

오늘날 자바스크립트 배열은 네 가지 면에서 객체와 다르다.

- `length` 속성
  - 배열이 담고 있는 요소의 개수를 의미하는 것이 아니라 가장 큰 색인보다 1 큰 값을 나타냄
- `Array.prototype` 을 상속함
- 객체 리터럴이 아닌 배열 리터럴을 사용해 만들어짐.
  - `[` , `]` , `,` 사용
- JSON은 배열과 객체를 다르게 취급하는 반면, JS는 둘을 비슷하게 처리함.

```jsx
var a = [1, 2, 3];
a[10] = 11;

a.length; // 11
```

자바스크립트 배열이 `typeof` 의 결과는 `"object"` 가 나옴. 따라서 `Array.isArray(value)` 를 사용해야만 함.

## 배열의 원점

첫 번째 라는 단어는 1과 연관되어 있어 작자는 0번째(zeroth)라는 말을 사용하겠다고 함.

## 초기화

- 배열을 만드느 2가지 방법
  - 배열 리터럴
  - `new Array(정수)`

```jsx
let my_little_array = new Array(10).fill(0);
let same_thing = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];

my_little_array === same_thing; // false
```

주소값이 다르다.

## 스택과 큐

배열은 배열을 스택처럼 쓸 수 있게하는 메서드들을 가지고 있음

- `pop`
- `push`
- `shift` : `pop` 메서드와 유사하지만, 배열의 마지막 요소 대신 0번째 요소를 제거하고 반환
- `unshift` : `push` 와는 달리 배열의 가장 앞에 새로운 요소를 추가

`shift` 와 `unshift` 는 `pop` 과 `push` 에 비해 많이 느리다. 특히 배열이 크면 심함.

## 검색

- `indexOf` : 배열의 0번째 요소부터 비교하며 찾음
  - 배열에 찾는 값이 없으면 `-1` 을 반환
- `lastIndexOf` : 배열의 뒤쪽부터 검색
- `includes` : 값이 있으면 `true` , 없으면 `false` 를 반환함.

## 축약

- `reduce` 메서드는 배열을 하나의 값으로 축약합니다.
- `reduce` 에 `Math.max` 함수를 전달하면 초기 값은 `-Infinity` 여야 합니다.
  - 0번째 요소가 초기 축약(`acc`)값
  - `.reduce((acc, value) => Math.max(acc, value));`
- `reduceRight`

## 반복

`forEach`

- `every` : 반환 값이 `false` 이거나 `false` 로 처리할 수 있는 값이면 처리를 멈추고 `false` 를 반환.
- `some` : `every` 의 반대
  - 반환 값이 `true` 이거나 `true` 로 처리할 수 있는 값이면 처리를 멈추고 `true` 를 반환.
- `find` : `some` 메서드 처럼 동작하지만, `true` 나 `false` 를 반환하지 않고 처리 중인 배열 요소의 값을 반환
- `findIndex` : `find` 와 같지만 배열 요소의 색인을 반환
- `filter` : `find` 와 같지만 반환값이 `true` 인 배열 요소의 값을 반환
- `map` : `forEach` 와 비슷하지만 인자로 전달된 함수의 모든 반환 값을 모아서 새로운 배열로 반환.

`reduce` 는 `reduceRight` 가 있지만 `forEach` , `map` , `filter` , `find` 는 방법이 없음.

저자는 `for` 구문이 사라질까봐라고 하는데… 이유는 모르겠음

## 정렬

- `sort` 의 문제점
  - `sort` 메서드는 추가 메모리 공간을 사용하지 않고 배열 자체를 수정
  - 안정성이 부족

## 그 외의 내용

- `concat`
- `join`
- `reverse`
  - `sort` 와 마찬가지로 배열 자체를 수정

## 순수함, 그리고 순수하지 않음

목록을 쭉 보여줌

- 본인 생각에 순수 했어야 했던 비순수 함수
  - `reverse`
  - `sort`

`splice` 사용할때도 맨날 헷갈림…

# 8장. 객체

- `null` 과 `undefined` 를 제외한 모든 것을 객체로 취급.
- 객체 리터럴의 범위는 `{}` 중괄호로 결정됨
- 객체의 값으로 `undefined` 라는 값을 할당할 수는 있지만, 피하는 것이 좋음
  - 속성을 제거하고자 하면 `delete` 연산자 사용

## 대소문자

- 속성의 키 값은 대소문자를 비교함

## 복사

- `Object.assign`
- 요즘은 `{…object}`

## 상속

- `Object.create(prototype)`
  - 이미 있는 객체를 전달받아서 이를 상속받는 새로운 객체를 반환합니다.
- 속성에 두 가지 형태
  - 고유(own) 속성
    - `hasOwnProperty(string)` : 믿을만한 함수는 아니다…
  - 상속받은(inherited) 속성
- `Object.create(null)` 을 사용해서 객체가 아무것도 상속받지 않게 만들 수 있다.

## 키

- `Object.keys`

## 동결

- `Object.freeze`
  - deep freeze 는 아니다. 오직 최상위 객체만 동결되고, 프로토타입 체인의 다른 객체는 동결되지 않는다.

## 프로토타입과 동결을 같이 쓰지 마세요

## WeakMap

- 객체 속성 이름은 반드시 문자열이여야 한다는 것은 잘못된 점.
- 따라서 JS 가 WeakMap 이라는 어떤 키를 써도 동작하는 객체를 제공해 준다.
- `Symbol` 비추
