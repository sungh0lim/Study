# 17장. 클래스 없는 자바스크립트

- 객체 지향 프로그래밍 개발에서 프로그램의 각 부분이 서로 통신하는 모델은 중요하다.
- 메서드 이름과 인자는 메시지와 같다.
  - 메서드 호출이란 객체에 메세지를 보내는 행위이다.
  - 객체는 메서드를 받았을 때 고유한 동작을 한다.
  - 메시지를 보내는 쪽은 받는 쪽이 무슨 행동을 할지 예상할 수 있다.
- 하지만 다형성으로 인해 달라질 수 있다.
  - 객체가 어떻게 만들어졌냐에 따라 다른 일이 일어날 수 있다.
- 상속은 아주 강력한 코드 재사용 기법이다.
  - 상속은 “거의 같지만, 예외가 있다"라는 생각에 기초를 둔다.
  - ‘객체 또는 객체클래스’들은 ‘다른 객체 또는 객체클래스’과 차이가 있다.
  - 스몰토크라는 언어에서 프로그램이 복잡해지면서 상속이 많은 문제를 일으켰다.
    - 상속은 클래스 사이의 강한 결합도를 유발한다.
    - 한 클래스에 가해지는 변경은 의존적인 다른 클래스에 문제를 일으킨다.
- 클래스 때문에 객체의 속성에 너무 많은 주의를 기울이게 된다.
  - ex. `getter` , `setter`
  - 최악의 경우 속성들이 공개되어 객체가 모르게 변경될 수 있다.
  - 좋은 설계에서는 속성들이 숨겨져 있고 메서드들이 속성 값을 단순히 변경하는 것이 아닌 트랜잭션을 처리한다.
- 타입에 대한 지나친 의존도 문제가 있다.
  - 타입 검사를 통해 찾을 수 있는 버그는 소수에 불과하다. (타입 검사를 통과해도 에러는 발생한다.)

## 생성자

```jsx
function counter_constructor() {
  let counter = 0;

  function up() {
    counter += 1;
    return counter;
  }

  function down() {
    counter -= 1;
    return counter;
  }

  return Object.freeze({
    up,
    down,
  });
}
```

- 좋은 캡슐화 방법
  - 반환되는 객체는 동결된(`Object.freeze`) 상태이다.
    - 따라서 손상되거나 오염되지 않는다.
  - `counter` 변수는 `private` 속성이다.
    - 메서드를 통해서만 접근 가능
    - `this` 사용하여 접근할 필요없다.
- 생성자는 객체를 반환하는 함수이다.
  - 생성자의 매개변수는 객체의 `private` 속성이 된다.
- 메서드는 트랜젝션으로 구현되어야 한다.
  - 하나의 데이터 단위는 동시에 변경되어야 한다.
    - ex. 주소 시, 군, 구
- 객체의 두 가지 종류
  - 메서드만 가지고 있는 단단한 객체(hard object)
    - 클로저 내부에 있는 데이터에 대한 완전성을 보호하며 다형성과 캡슐화를 제공한다.
  - 데이터만 가지고 있는 부드러운 객체(soft object)
    - 정의된 동작이 없으며 함수에 의해 처리될 수 있는 편리한 데이터 집합이다.

## 생성자 매개변수

- 매개변수 여러개가 있는 생성자의 경우 매개변수로 하나의 객체만 전달받도록 만들자.
  - 이점
    - key 문자열 값이 코드 자체를 문서화해 준다. 호출할 때 어떤 인자가 어떤 일을 하는지 코드 자체가 알려 주기 때문에 가독성이 증가한다.
    - 인자가 어떤 순서로 전달되어도 상관 없다.
    - 기존의 코드를 수정하지 않고도 새로운 인자를 추가할 수 있다.
    - 쓸모없는 매개변수는 무시된다.
- 매개변수의 가장 흔한 용도는 `private` 속성 값 초기회.
  - 만약 값이 없다면 `undefined` 로 초기화된다.

## 컴포지션

```jsx
function my_little_constructor(spec) {
  let { member } = spec;

  const reuse = other_constructor(spec);
  const method = function () {
    // 이 method 는 spec, member, reuse, method를 사용할 수 있습니다.
  };

  return Object.freeze({
    method,
    goodness: reuse.goodness,
  });
}
```

## 크기

- 이렇게 객체를 생성하는 방법은 프로토타입을 쓰는 방법보다 메모리를 더 많이 사용한다.
  - 하지만 그렇게 크지는 않다.
  - 오히려 모듈화에서는 더 좋다.

# 18장. 꼬리 호출

- 프로그램을 더 빠르게 만들기 위해 최적화한다.
  - 최적화는 규칙을 깨지만 규칙을 깬다는 것을 모르게해야한다.
  - 최적화는 버그를 만들거나 나쁜 프로그램을 만들어서는 안된다.
- 꼬리 호출은 함수가 마지막으로 하는 일이 어떤 함수를 호출해 그 결과를 바로 반환할 때 일어난다.

```jsx
function continuize(any) {
  return function hero(continuation, ...args) {
    return continuation(any(...args)); // 꼬리 호출
  };
}
```

### 설명

```jsx
call continuation # continuation 함수를 호출함
return # hero 함수를 호출한 함수로 돌아감
```

- `call` 명령어는 다음 명령어의 주소를 호출 스택에 저장한다.
  - 예제에서의 `return` 명령어의 주소
- 함수로 실행 흐름을 변경한다.
  - 변경되는 목적 주소는 `continuation` 이라고 명명된 레지스터에 저장되어 있다.
- `continuation` 함수가 끝나면 스택에 저장된 주소 값을 꺼내와서 실행 흐름을 변경하는데, 위의 경우에는 `return` 명령어의 주소가 된다.
- 실행되는 `return` 명령어는 다시 호출 스택에서 `hero` 함수 호출의 다음 명령어 주소를 꺼내와서 실행 흐름을 변경한다.
- 최적화는 이 두 명령어를 하나의 명령어로 대체한다.

```jsx
jump continuation # continuation 함수로 점프
```

- 이렇게 하면 호출 스택에 `return` 명령어의 주소 값을 저장하지 않는다.

### js 의 함수 호출

- 인자 표현식을 계산한다.
- 함수의 매개변수와 변수를 저장할 수 있는 충분한 크기의 활성 객체를 생성한다.
- 호출된 함수 객체에 대한 참조를 새로운 활성 객체에 저장한다.
- 전달받은 인자를 새로운 활성 객체의 매개변수에 저장한다. 빠진 인자는 `undefined` 로 간주한다. 남은 인자는 버린다.
- 활성 객체의 모든 변수 값을 `undefined` 로 지정한다.
- 함수 호출 명령어의 바로 다음 명령어를 활성 객체의 다음 명령어 필드 값으로 지정한다.
- 새로운 활성 객체의 호출자(caller) 필드 값에 현재 활성 객체를 지정한다. (실제 호출 스택이 아니라 활서 ㅇ객체의 연결된 목록)
- 새로운 활성 객체를 현재 활성 객체로 지정한다.
- 호출된 함수를 실행한다.

### 최적화한 경우

- 인자 표현식을 계산한다.
- 현재 활성 객체가 충분히 크다면
  - 현재 활성 객체를 새로운 활성 객체로 사용한다.
- 그렇지 않다면
  - 함수 매개변수와 변수를 저장할 수 있는 충분한 크기의 활성 객체를 생성한다.
  - 새로운 활성 객체의 호출자(caller) 필드 값에 현재 활성 객체를 지정한다.
  - 새로운 활성 객체를 현재 활성 객체로 지정한다.
- 호출된 함수 객체에 대한 참조를 새로운 활성 객체에 저장한다.
- 전달받은 인자를 새로운 활성 객체의 매개변수에 저장한다. 빠진 인자는 `undefined` 로 간주한다. 남은 인자는 버린다.
- 활성 객체의 모든 변수 값을 `undefined` 로 지정한다.
- 호출된 함수를 실행한다.

### 중요한 차이점

- 메모리 할당과 가비지 컬렉션에 드는 시간을 줄인다.
- 꼬리 호출 최적화를 통해 재귀 함수 호출을 반복문만큼 빠르게 만들 수 있다.

## 꼬리 위치

- 함수가 반환하는 값이 바로 반환되는 경우 해당 함수 호출은 꼬리 호출이라고 합니다.

```jsx
return typeof any === "function" ? any() : undefined; // 꼬리 호출 예시
```

- 논리 연산자 `&&` 이나 `||` 를 사용하는 반환 표현식도 꼬리호출이 될 수 있다.

### 꼬리 호출이 아닌 경우

```jsx
// 1
return 1 + any();

// 2
any();
return;

// 3
const value = any();
return value;
```

### 재귀

- 재귀는 일반적으로 꼬리 호출이 아니다.

```jsx
function factorial(n) {
  if (n < 2) {
    return 1;
  }

  return n * factorial(n - 1);
}
```

- 함수 호출을 꼬리 위치로 옮긴다면 최적화 할 수 있다.

```jsx
function factorial(n, result = 1) {
  if (n < 2) {
    return result;
  }

  return factorial(n - 1, n * result);
}
```

### 새로운 함수 객체를 반환

```jsx
return function () {}; // 꼬리 호출이 아님
return (function () {})(); // 꼬리 호출
```

## 예외

- `try` 블록 내에서는 꼬리 호출 최적화되지 않는다.
- 함수가 새로운 함수 객체를 만드는 경우 새로운 함수 객체는 함수 객체를 만든 활성 객체에 접근할 수 있어야 하므로 활성 객체를 최적화해서는 안된다.

## 연속 전달 스타일

- 프로그램의 흐름은 일반적으로 앞으로 나아가며, 뒤돌아가서 이전 상태를 점검하는 경우는 드물다.
- 꼬리 호출을 최적화를 통해 연속성을 갖는 함수를 구현할 수 있다.

## 디버깅

- 꼬리 재귀의 경우 디버깅이 어렵다.
- 좋은 디버거는 활성 객체의 상태가 변할 경우 복사본을 만들고, 가장 최신의 객체를 유지하는 방식으로 디버깅을 더 쉽게 해준다.

# 19장. 순수함

- 함수형 프로그래밍은 말 그대로 함수로 프로그래밍하는 것을 뜻한다.
- 수학적인 함수는 소프트웨어 함수보다 훨씬 더 순수하다고 여겨집니다.

## 순수함의 축복

- 순수함은 몇 가지 중요한 가치를 가집니다.
  - 순수함은 아주 훌륭한 모듈화를 내포하고 있습니다.
  - 테스트하기도 쉽습니다.
  - 구성하기가 좋습니다.
    - 사이드 이펙트가 없고 외부에 의존성도 없고 영향받지 않는다.
  - 성능에서도 유리할 예정이다.
    - 신뢰성과 성능 문제를 해결할 수 있는 좋은 방법이다.
  - 안전하며 효과적이다.
- 순수함수의 병렬화가 진짜 필요한 기능인데 안만들어주고 자꾸 다른거 만든다.

## 순수해지기

### 언어의 순수하지 않은 부분

- `var` , `let` 을 포함한 할당 연산자를 사용하지 말자.
  - `const` 써라.
- `delete` , `Object.assign` 메서드와 같이 객체를 수정하는 연산자나 메서드를 제거하자.
- `getter` , `setter` 도 없애자.
- 정규표현식의 `exec` 도 `lastIndex` 속성을 변경하기 때문에 없애자.
- `for` 쓰지 말자.
  - 차라리 꼬리 재귀하자.
- `Date` 없애자.
  - 호출할 때마다 다른 값을 가져온다.
  - `Math.random` 도 같은 이유다.
- 사용자도 개입되면 안된다.
- 네트워크와도 연결되면 안된다.

## 세상이라는 문제

- 세상이 순수하지 않다.
- 순수하게 만들도록 노력하자.

## 연속체

- 순수함에는 연속성이 있다.
- 수학적인 함수가 최상위이다.
- 그 다음은 병렬 어플리케이션에도 쓸 수 있을 만큼 충분히 순수한 함수.
  - ???
- 순수한 고차함수
- 상태를 가지는 고차함수
- 그 아래에… 클래스, 프로시저 등등
- 제일 밑에 전역변수 등등

# 20장. 비동기 프로그래밍

- 처음에는 순차적 프로그래밍이 있었다.
- 프로그래밍 언어도 순차적으로 만들어졌다.
  - 이렇게 될줄 몰랐다.
- 순차적 언어는 입출력을 블록(block) 방식으로 처리한다.
  - 프로그램이 파일을 읽거나 네트워크에서 데이터를 가져오려면, 데이터를 다 가져올때까지 프로그램은 실행을 멈춘다.
- 하지만 자바스크립트는 사용자와의 상호작용을 위해 더 나은 모델을 따르고 있다.

## 동시성

- 사용자, 다른 컴퓨터와의 상호작용을 위해 동시성(concurrent programming)이 필요해졌다.
- 동일한 유형의 동시성은 비슷한 많은 동작이 같은 시간에 처리될 수 있도록 해준다.
  - ex. 배열의 `map`
- 서로 다른 유형의 동시성은 각각 서로 다른 책임을 지는 특별한 프로세스들의 협업을 가능하게 한다.

## 스레드

- 애플리케이션에서의 스레드는 달라야한다.

## 비동기 프로그래밍

- 비동기 프로그래밍은 콜백 함수와 프로세싱 루프(processing loop)에 근간한다.
  - 프로세싱 루프 = 이벤트 루프, 메시지 루프
- 이벤트 루프에 대한 설명

## 턴의 법칙

## 서버 세상에서의 문제

## 리퀘스터

## 잘못된 단어로 인한 혼란

- `synchronized` 가 된 것도 이해가 안가는데
- 반대를 의미하는 `a` 를 붙여 `async` 가 되니 더 이해가 안간다.
