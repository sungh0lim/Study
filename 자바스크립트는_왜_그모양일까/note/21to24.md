# 21장. Date

- 그레고리력 (`4|100|400` 알고리즘)
  - 100으로는 나누어 떨어지지 않지만 4로 나누어 떨어지는 해에는 하루를 더한다.
  - 하지만 400으로 나누어 떨어지는 해에는 무조건 하루를 더한다.
  - 한 해는 평균 `365.2425` 일로 구성된다. (태양년은 `365.242188792`)
- 더 나은 방법 (`4|128` 알고리즘)
  - 128로는 나누어 떨어지지 않지만 4로 나누어 떨어지는 해에는 하루를 더한다.
  - 이렇게하면 한해는 평균 `365.2421875` 일이 되어 태양년과 더 근접해진다.
- March ~ December + January + February 가 되었다.
  - February 에 하루를 추가하게 되었다.
- 시분초
  - 분과 초는 시작이 0이지만 60진법을 사용한다.
  - 시도 12진법을 사용

## Date 함수

- 자바스크립트의 `Date` 함수는 대부분 `getter / setter` 인 많은 메서드들을 제공한다.
  - 자바의 안좋은 것을 그대로 가져다 사용했다.
  - `getMonth` 는 0부터 시작하지만 `getDate` 는 1부터 시작한다.
  - `getYear` 와 `setYear` 는 1999년도 이후로 제대로 동작하지 않는다.
    - 대신 `getFullYear` , `getSetYear` 를 사용하자.
- `Date` 는 정말 안좋은 선례이다.
  - 객체와의 상호 작용은 트랜잭션 형태여야 한다.

## ISO 8601

- 날짜와 시간을 나타내는 국제 표준인 ISO 8601 을 자바스크립트에도 추가해야한다.

## 다른 접근 방법

- 날짜는 세 가지 방식으로 표현할 수 있음
  - epoch 이후로 흐른 밀리초(1/1000초) 값
  - 아래 속성을 가지는 데이터 객체
    - year, month, day, hour, minute, second, zone, week, weekday
  - 표준 포맷을 따르는 문자열
- 세 가지 표현 방식 간에 변환을 제공하는 함수가 필요함.
  - `Date.now()` 는 현재 시간을 숫자로 반환한다. (이미 있음)
  - `Date.object()` 는 숫자나 문자열을 받아서 추출할 수 있는 정보를 가지는 객체를 반환한다.
  - `Date.string()` 은 숫자나 데이터 객체, 그리고 부수적인 표시 형식 표준과 타입존을 전달받아서 사람이 읽을 수 있는 형태로 시간을 표시해 주는 문자열을 반환한다.
  - `Date.number()` 은 데이터 객체나 문자열, 그리고 부수적인 표시 형식 표준과 타임 존을 전달받아서 시간을 표시하는 숫자를 반환한다.
- JS의 epoch 는 유닉스 epoch로 `1970-01-01` 이다.
  - `0000-01-01` 이였으면 좋겠다.

## 22장. JSON

JSON 만든사람의 JSON 기원이야기

## 발견

- 브라우저와 서버 간에 정보를 전달할 수 있는 방법이 필요했음.
  - 기존에는 XML이 지배중.

## 표준화

- JSON 형식을 갖추고 널리널리 알렸다.
- JS의 안좋은 점은 감추고자 했다.
  - 못감춘것도 있다.

## JSON이 동작할 수 있는 이유

- 모든 프로그램의 공통점을 찾아 서로 다른 언어로 만들어진 프로그램이 서로 통신할 수 있게 했음

## 영향

## JSON 객체

- `JSON` 객체의 두 함수
  - `JSON.parse` → decode
  - `JSON.stringify` → encode
- `toJSON`

## 보안적 영향

- `JSON` 을 처음 사용할 때는 `eval` 을 사용하여 디코딩했기때문에 위험했다.
- `JSON.stringify` 를 사용하자.

## McKeeman 표기법

## JSON 문법

- McKeeman 표기법으로 JSON 문법을 정리

## 데이터 표준 설계자들을 위한 조언

- JSON을 파괴하지 마세요.
- 훨씬 더 낫게 만드세요.
- 더 좋은 이름을 붙이세요.

# 23장. 테스팅

## 버그

- 프로그램에서 혼란이 발생할 부분은 최대한 없어야한다.
- 혼란을 없애는 것이 테스트하는 것보다 훨씬 더 생산적이다.

## 비대한 소프트웨어

- 규칙 없이 기능을 마구 추가하거나 잘못된 구조로 비대해질 수 있다.
- 프로그램이 비대해지면 공격받을 부분도, 버그가 숨을 부분도 많아진다.
- Lazy loading, Three Shaking 으로 필요없는 코드를 지연시키거나 제거하는 방법이 있다.
  - 하지만 비대함을 관리하기 위해 코드가 더 비대해지기도 한다.
- 비대해지지 않으려면, 비대하지 않게 만들어야 한다.
  - 설계와 개발에서 소프트웨어의 단순함을 최우선으로 삼아야 한다.

## 테스트 주도 개발

- 방법론으로 TDD 는 좋아하지만 종교로서 TDD는 싫어한다.
- 단위테스트는 저수준 코드에서는 효과적이지만 고수준으로 갈수록 의존성이 증가하면서 테스트가 점점 의미가 없어진다.
  - 테스트를 만드는 비용이 점점 더 증가한다.
- 테스팅 라이브러리인 JSCheck 을 소개하는데 넘어가자.

# 24장. 최적화

최적화를 최적화할 필요가 있다.

## 측정

개발자의 일은 대부분 정량화할 수 없지만, 코드가 복잡해지면 고민해봐야한다.

측정하고, 잘라내고, 다시 측장하라.

## 시간을 갉아먹는 것들

병렬화에 실패, 턴의 법칙 위반, 낮은 응집도, 강한 결합도, 잘못된 알고리즘, 스래싱, 비대한 소프트웨어, 다른 사람이 만든 코드.

## 언어

단순하고, 깔끔하고, 균형 잡힌 언어가 최적화하기 더 쉬울 것이다.
